/***********************************************************
*   函数库说明：底层硬件初始化驱动函数库                   *
*   版本：    	Ver1.0                                     *
*   作者：    	zzjjhh250/ZZJJHH250 @ (CopyRight)          *
*   创建日期：	08/31/2010                                 *
* -------------------------------------------------------- *
*  [硬件说明]                                              *
*   处理器：    STM32F103VBT6                              *
*   系统时钟：  外部8M/PLL = 72M                           *
* -------------------------------------------------------- *
*  [支 持 库]                                              *
*   支持库名称：PF_Config.h                                *
*   需要版本：  -----                                      *
*   声明库说明：硬件平台配置声明库                         *
*                                                          *
*   支持库名称：HD_Support.h                               *
*   需要版本：  -----                                      *
*   声明库说明：底层硬件初始化声明库                       *
*                                                          *
*   支持库名称：EX_Support.h                               *
*   需要版本：  -----                                      *
*   声明库说明：底层硬件初始化驱动声明库                   *
* -------------------------------------------------------- *
*  [版本更新]                                              *
*   修改：                                                 *
*   修改日期：                                             *
*   版本：                                                 *
* -------------------------------------------------------- *
*  [版本历史]                                              *
* -------------------------------------------------------- *
*  [使用说明]                                              *
***********************************************************/

/********************
* 头 文 件 配 置 区 *
********************/
# include "..\Source\PF_Config.h"
# include "..\Source\EX_Support.h"
#include  "..\Source\LIB_Config.h"


/********************
*   系 统 宏 定 义  *
********************/

/*------------------*
*   常 数 宏 定 义  *
*------------------*/
#define USART1_RX_BUF_SIZE	64	/*必须是2的幂*/
#define USART1_TX_BUF_SIZE	128	/*必须是2的幂 2k*/


#define USART2_RX_BUF_SIZE	64	/*必须是2的幂*/
#define USART2_TX_BUF_SIZE	64	/*必须是2的幂 2k*/

/*------------------*
*   动 作 宏 定 义  *
*------------------*/
 
/********************
*  模块结构体定义区 *
********************/

/********************
*   函 数 声 明 区  *
********************/
void 	Delay_20ms(u32 speed);


//void Driver_Init(void);

/********************
*   模块函数声明区  *
********************/
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

void 	USART1_RxBufferInit(void);
u8 		USART1_PutDatatoRxBuffer(u8 dat);
u16 	USART1_GetRxBufferLeftLength(void);
u8 		USART1_GetRxBufferData( void );
u16 	USART1_GetRxBufferCurrentSize( void );
void    USART1_FlushRxBuffer( void );
void 	USART1_GetBytesFromRxFIFO( u8 *pdat ,u16 length);


void 	USART2_RxBufferInit(void);
u8 		USART2_PutDatatoRxBuffer(u8 dat);
u16 	USART2_GetRxBufferLeftLength(void);
u8 		USART2_GetRxBufferData( void );
u16 	USART2_GetRxBufferCurrentSize( void );
void    USART2_FlushRxBuffer( void );
void 	USART2_GetBytesFromRxFIFO( u8 *pdat ,u16 length);
											  
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

void 	USART1_TxBufferInit(void);
u8 		USART1_PutDatatoTxBuffer(u8 dat);
u16 	USART1_GetTxBufferLeftLength(void);
u8 		USART1_GetTxBufferData( void );
u16 	USART1_GetTxBufferCurrentSize( void );
void    USART1_FlushTxBuffer( void );

void 	USART1_PutBytesToTxFIFO( u8 *pdat ,u16 length);	


void 	USART1_QueryPutMultiChar( u8 *pdat ,u16 length);
void 	USART1_QueryPutChar( u8 dat );





void 	USART2_TxBufferInit(void);
u8 		USART2_PutDatatoTxBuffer(u8 dat);
u16 	USART2_GetTxBufferLeftLength(void);
u8 		USART2_GetTxBufferData( void );
u16 	USART2_GetTxBufferCurrentSize( void );
void    USART2_FlushTxBuffer( void );

void 	USART2_PutBytesToTxFIFO( u8 *pdat ,u16 length);	


void 	USART2_QueryPutMultiChar( u8 *pdat ,u16 length);
void 	USART2_QueryPutChar( u8 dat );

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void 	UASRT1_BeginSend(void);
void 	UASRT1_StopSend(void);

void 	UASRT2_BeginSend(void);
void 	UASRT2_StopSend(void);

void 	USART1_StopRx(void);
void 	USART1_BeginRx(void);

void 	USART2_StopRx(void);
void 	USART2_BeginRx(void);
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/********************
*   模块变量声明区  *
********************/

static u8 USART1_RXBuffer[USART1_RX_BUF_SIZE]; 	 //USART1 发送缓冲区FIFO
static cBuffer  USART1_tRXBufferMana;			 //管理结构体变量

static u8 USART1_TXBuffer[USART1_TX_BUF_SIZE]; 	 //USART1 发送缓冲区FIFO
static cBuffer  USART1_tTXBufferMana;	 		 //管理结构体变量


#if 0
static u8 USART2_RXBuffer[USART2_RX_BUF_SIZE]; 	 //USART2 发送缓冲区FIFO
static cBuffer  USART2_tRXBufferMana;			 //管理结构体变量

static u8 USART2_TXBuffer[USART2_TX_BUF_SIZE]; 	 //USART2 发送缓冲区FIFO
static cBuffer  USART2_tTXBufferMana;	 		 //管理结构体变量
#endif


/********************
*   全局变量声明区  *
********************/
u16 g_wSysTime1 = 0;   //系统定时
u16 g_wSysTime2 = 0;
u16 g_wSysTime3 = 0;
u16 g_wSysTime4 = 0;

 
u16 counter1=0;	 
u16 counter2=1; 
u16 counter3=2;
u16 counter4=3;


volatile bool ADC_OnceFlag = FALSE;
union16_type ADC_Val[6] = {0}; 

/*
 * 0 -- 表示无谐波
 * 1 -- 30次谐波幅值是基波幅值的1/10
 * 2 -- 30次谐波幅值是基波幅值的2/10
 * 3 -- 30次谐波幅值是基波幅值的3/10
 * 4 -- 30次谐波幅值是基波幅值的4/10
 * 5 -- 30次谐波幅值是基波幅值的5/10
 * */
#define HARMONIC_WAVE_AMPLITUDE	3


 uc16 Sine12bit[400] = {
#if 0
0x7FF,0x82A,0x855,0x880,0x8AA,0x8D5,0x900,0x92A,0x954,0x97F,0x9A9,0x9D3,0x9FC,0xA26,0xA4F,0xA78
,0xAA0,0xAC9,0xAF1,0xB18,0xB40,0xB67,0xB8D,0xBB4,0xBD9,0xBFF,0xC24,0xC48,0xC6C,0xC90,0xCB2,0xCD5
,0xCF7,0xD18,0xD39,0xD59,0xD79,0xD98,0xDB6,0xDD4,0xDF1,0xE0D,0xE29,0xE44,0xE5E,0xE77,0xE90,0xEA8
,0xEC0,0xED6,0xEEC,0xF01,0xF16,0xF29,0xF3C,0xF4D,0xF5F,0xF6F,0xF7E,0xF8D,0xF9A,0xFA7,0xFB3,0xFBE
,0xFC8,0xFD2,0xFDA,0xFE2,0xFE9,0xFEE,0xFF3,0xFF7,0xFFA,0xFFD,0xFFE,0xFFE,0xFFE,0xFFD,0xFFA,0xFF7
,0xFF3,0xFEE,0xFE9,0xFE2,0xFDA,0xFD2,0xFC8,0xFBE,0xFB3,0xFA7,0xF9A,0xF8D,0xF7E,0xF6F,0xF5F,0xF4D
,0xF3C,0xF29,0xF16,0xF01,0xEEC,0xED6,0xEC0,0xEA8,0xE90,0xE77,0xE5E,0xE44,0xE29,0xE0D,0xDF1,0xDD4
,0xDB6,0xD98,0xD79,0xD59,0xD39,0xD18,0xCF7,0xCD5,0xCB2,0xC90,0xC6C,0xC48,0xC24,0xBFF,0xBD9,0xBB4
,0xB8D,0xB67,0xB40,0xB18,0xAF1,0xAC9,0xAA0,0xA78,0xA4F,0xA26,0x9FC,0x9D3,0x9A9,0x97F,0x954,0x92A
,0x900,0x8D5,0x8AA,0x880,0x855,0x82A,0x7FF,0x7D4,0x7A9,0x77E,0x754,0x729,0x6FE,0x6D4,0x6AA,0x67F
,0x655,0x62B,0x602,0x5D8,0x5AF,0x586,0x55E,0x535,0x50D,0x4E6,0x4BE,0x497,0x471,0x44A,0x425,0x3FF
,0x3DA,0x3B6,0x392,0x36E,0x34C,0x329,0x307,0x2E6,0x2C5,0x2A5,0x285,0x266,0x248,0x22A,0x20D,0x1F1
,0x1D5,0x1BA,0x1A0,0x187,0x16E,0x156,0x13E,0x128,0x112,0x0FD,0x0E9,0x0D5,0x0C2,0x0B1,0x09F,0x08F
,0x080,0x071,0x064,0x057,0x04B,0x040,0x036,0x02C,0x024,0x01C,0x015,0x010,0x00B,0x007,0x004,0x001
,0x000,0x000,0x000,0x001,0x004,0x007,0x00B,0x010,0x015,0x01C,0x024,0x02C,0x036,0x040,0x04B,0x057
,0x064,0x071,0x080,0x08F,0x09F,0x0B1,0x0C2,0x0D5,0x0E9,0x0FD,0x112,0x128,0x13E,0x156,0x16E,0x187
,0x1A0,0x1BA,0x1D5,0x1F1,0x20D,0x22A,0x248,0x266,0x285,0x2A5,0x2C5,0x2E6,0x307,0x329,0x34C,0x36E
,0x392,0x3B6,0x3DA,0x3FF,0x425,0x44A,0x471,0x497,0x4BE,0x4E6,0x50D,0x535,0x55E,0x586,0x5AF,0x5D8
,0x602,0x62B,0x655,0x67F,0x6AA,0x6D4,0x6FE,0x729,0x754,0x77E,0x7A9,0x7D4
#elif 0==HARMONIC_WAVE_AMPLITUDE
/*
----------------fundamental-wave data----------------
amplitude:+1848, angular_frequency: +1, initial_phase:+0.00
*/

+2048, +2086, +2125, +2164, +2202, +2241, +2279, +2317, +2356, +2394, +2432, +2469, +2507, +2544, +2582, +2619,
+2655, +2692, +2728, +2764, +2799, +2834, +2869, +2904, +2938, +2971, +3005, +3038, +3070, +3102, +3134, +3165,
+3195, +3225, +3255, +3284, +3313, +3340, +3368, +3395, +3421, +3446, +3471, +3496, +3519, +3543, +3565, +3587,
+3608, +3628, +3648, +3667, +3685, +3703, +3720, +3736, +3751, +3766, +3780, +3793, +3805, +3817, +3827, +3837,
+3847, +3855, +3863, +3870, +3876, +3881, +3885, +3889, +3892, +3894, +3895, +3896, +3895, +3894, +3892, +3889,
+3885, +3881, +3876, +3870, +3863, +3855, +3847, +3837, +3827, +3817, +3805, +3793, +3780, +3766, +3751, +3736,
+3720, +3703, +3685, +3667, +3648, +3628, +3608, +3587, +3565, +3543, +3519, +3496, +3471, +3446, +3421, +3395,
+3368, +3340, +3313, +3284, +3255, +3225, +3195, +3165, +3134, +3102, +3070, +3038, +3005, +2971, +2938, +2904,
+2869, +2834, +2799, +2764, +2728, +2692, +2655, +2619, +2582, +2544, +2507, +2469, +2432, +2394, +2356, +2317,
+2279, +2241, +2202, +2164, +2125, +2086, +2047, +2009, +1970, +1931, +1893, +1854, +1816, +1778, +1739, +1701,
+1663, +1626, +1588, +1551, +1513, +1476, +1440, +1403, +1367, +1331, +1296, +1261, +1226, +1191, +1157, +1123,
+1090, +1057, +1025,  +993,  +961,  +930,  +900,  +870,  +840,  +811,  +782,  +755,  +727,  +700,  +674,  +649,
 +624,  +599,  +576,  +552,  +530,  +508,  +487,  +467,  +447,  +428,  +410,  +392,  +375,  +359,  +344,  +329,
 +315,  +302,  +290,  +278,  +268,  +258,  +248,  +240,  +232,  +225,  +219,  +214,  +210,  +206,  +203,  +201,
 +200,  +200,  +200,  +201,  +203,  +206,  +210,  +214,  +219,  +225,  +232,  +240,  +248,  +258,  +268,  +278,
 +290,  +302,  +315,  +329,  +344,  +359,  +375,  +392,  +410,  +428,  +447,  +467,  +487,  +508,  +530,  +552,
 +576,  +599,  +624,  +649,  +674,  +700,  +727,  +755,  +782,  +811,  +840,  +870,  +900,  +930,  +961,  +993,
+1025, +1057, +1090, +1123, +1157, +1191, +1226, +1261, +1296, +1331, +1367, +1403, +1440, +1476, +1513, +1551,
+1588, +1626, +1663, +1701, +1739, +1778, +1816, +1854, +1893, +1931, +1970, +2009, +2047,
#elif 1==HARMONIC_WAVE_AMPLITUDE
/*
----------------fundamental-harmonic-wave data----------------

harmonic amplitude level:1.00
[ 0] amplitude:+1848, angular_frequency: +1, initial_phase:+0.00

harmonic amplitude level:0.11
[ 1] amplitude: +204, angular_frequency:+30, initial_phase:+0.00
*/

+2048, +2206, +2319, +2358, +2322, +2241, +2159, +2123, +2162, +2274, +2432, +2589, +2701, +2738, +2702, +2619,
+2535, +2498, +2534, +2644, +2799, +2954, +3063, +3098, +3058, +2972, +2885, +2844, +2876, +2982, +3134, +3285,
+3389, +3419, +3375, +3284, +3193, +3146, +3174, +3275, +3421, +3566, +3665, +3690, +3639, +3543, +3445, +3393,
+3414, +3508, +3648, +3787, +3879, +3897, +3840, +3736, +3631, +3572, +3586, +3673, +3805, +3937, +4021, +4031,
+3967, +3855, +3743, +3676, +3682, +3761, +3885, +4009, +4086, +4088, +4015, +3895, +3775, +3700, +3698, +3769,
+3885, +4001, +4070, +4064, +3983, +3855, +3727, +3643, +3633, +3697, +3805, +3913, +3974, +3960, +3871, +3736,
+3600, +3509, +3491, +3547, +3648, +3748, +3802, +3781, +3685, +3543, +3400, +3302, +3277, +3327, +3421, +3515,
+3562, +3534, +3432, +3284, +3135, +3031, +3001, +3045, +3134, +3222, +3264, +3232, +3125, +2971, +2818, +2710,
+2675, +2714, +2799, +2884, +2922, +2886, +2775, +2619, +2462, +2350, +2313, +2350, +2432, +2514, +2550, +2511,
+2399, +2241, +2082, +1970, +1931, +1966, +2048, +2129, +2164, +2125, +2013, +1854, +1696, +1584, +1545, +1581,
+1663, +1745, +1782, +1745, +1633, +1476, +1320, +1209, +1173, +1211, +1296, +1381, +1420, +1385, +1277, +1123,
 +970,  +863,  +831,  +873,  +961, +1050, +1094, +1064,  +960,  +811,  +663,  +561,  +533,  +580,  +674,  +768,
 +818,  +793,  +695,  +552,  +410,  +314,  +293,  +347,  +447,  +548,  +604,  +586,  +495,  +359,  +224,  +135,
 +121,  +182,  +290,  +398,  +462,  +452,  +368,  +240,  +112,   +31,   +25,   +94,  +210,  +326,  +397,  +395,
 +320,  +200,   +80,    +7,    +9,   +86,  +210,  +334,  +413,  +419,  +352,  +240,  +128,   +64,   +74,  +158,
 +290,  +422,  +509,  +523,  +464,  +359,  +255,  +198,  +216,  +308,  +447,  +587,  +681,  +702,  +650,  +552,
 +456,  +405,  +430,  +529,  +674,  +820,  +921,  +949,  +902,  +811,  +720,  +676,  +706,  +810,  +961, +1113,
+1219, +1251, +1210, +1124, +1037,  +997, +1032, +1141, +1296, +1451, +1561, +1597, +1560, +1476, +1393, +1357,
+1394, +1506, +1663, +1821, +1933, +1972, +1936, +1854, +1773, +1737, +1776, +1889, +2047,
#elif 2==HARMONIC_WAVE_AMPLITUDE
/*
----------------fundamental-harmonic-wave data----------------

harmonic amplitude level:1.00
[ 0] amplitude:+1848, angular_frequency: +1, initial_phase:+0.00

harmonic amplitude level:0.22
[ 1] amplitude: +409, angular_frequency:+30, initial_phase:+0.00
*/

+2048, +2327, +2514, +2553, +2443, +2241, +2039, +1928, +1967, +2153, +2432, +2710, +2896, +2933, +2822, +2619,
+2415, +2303, +2339, +2523, +2799, +3075, +3258, +3293, +3178, +2972, +2764, +2649, +2681, +2862, +3134, +3405,
+3584, +3614, +3495, +3284, +3072, +2951, +2979, +3154, +3421, +3687, +3860, +3885, +3760, +3543, +3325, +3198,
+3219, +3388, +3648, +3907, +4074, +4092, +3960, +3736, +3511, +3377, +3391, +3552, +3805, +4057, +4216, +4226,
+4087, +3855, +3622, +3481, +3487, +3641, +3885, +4129, +4281, +4283, +4135, +3895, +3655, +3505, +3503, +3649,
+3885, +4121, +4265, +4259, +4103, +3855, +3606, +3448, +3438, +3576, +3805, +4033, +4169, +4155, +3992, +3736,
+3479, +3314, +3296, +3427, +3648, +3869, +3997, +3976, +3805, +3543, +3279, +3107, +3082, +3206, +3421, +3635,
+3757, +3729, +3553, +3284, +3015, +2836, +2806, +2924, +3134, +3343, +3459, +3427, +3245, +2971, +2697, +2515,
+2480, +2594, +2799, +3004, +3117, +3081, +2896, +2619, +2341, +2155, +2118, +2229, +2432, +2634, +2745, +2706,
+2520, +2241, +1962, +1775, +1736, +1846, +2048, +2249, +2359, +2320, +2133, +1854, +1575, +1389, +1350, +1461,
+1663, +1866, +1977, +1940, +1754, +1476, +1199, +1014,  +978, +1091, +1296, +1501, +1615, +1580, +1398, +1123,
 +850,  +668,  +636,  +752,  +961, +1171, +1289, +1259, +1080,  +811,  +542,  +366,  +338,  +460,  +674,  +889,
+1013,  +988,  +816,  +552,  +290,  +119,   +98,  +226,  +447,  +668,  +799,  +781,  +616,  +359,  +103,   -59,
  -73,   +62,  +290,  +519,  +657,  +647,  +489,  +240,    -7,  -163,  -169,   -25,  +210,  +446,  +592,  +590,
 +440,  +200,   -39,  -187,  -185,   -33,  +210,  +454,  +608,  +614,  +473,  +240,    +8,  -130,  -120,   +38,
 +290,  +543,  +704,  +718,  +584,  +359,  +135,    +3,   +21,  +188,  +447,  +707,  +876,  +897,  +770,  +552,
 +335,  +210,  +235,  +408,  +674,  +941, +1116, +1144, +1023,  +811,  +600,  +481,  +511,  +690,  +961, +1233,
+1414, +1446, +1331, +1124,  +917,  +802,  +837, +1020, +1296, +1572, +1756, +1792, +1680, +1476, +1273, +1162,
+1199, +1385, +1663, +1942, +2128, +2167, +2056, +1854, +1652, +1542, +1581, +1768, +2047,
#elif 3==HARMONIC_WAVE_AMPLITUDE
/*
----------------fundamental-harmonic-wave data----------------

harmonic amplitude level:1.00
[ 0] amplitude:+1848, angular_frequency: +1, initial_phase:+0.00

harmonic amplitude level:0.33
[ 1] amplitude: +614, angular_frequency:+30, initial_phase:+0.00
*/

+2048, +2447, +2709, +2747, +2563, +2241, +1918, +1734, +1772, +2033, +2432, +2830, +3091, +3128, +2943, +2619,
+2294, +2108, +2144, +2403, +2799, +3195, +3453, +3488, +3299, +2972, +2644, +2454, +2486, +2741, +3134, +3526,
+3779, +3809, +3616, +3284, +2952, +2757, +2784, +3034, +3421, +3807, +4055, +4080, +3880, +3543, +3204, +3003,
+3024, +3267, +3648, +4028, +4269, +4287, +4081, +3736, +3390, +3182, +3196, +3432, +3805, +4178, +4411, +4421,
+4208, +3855, +3502, +3286, +3292, +3520, +3885, +4250, +4476, +4478, +4256, +3895, +3534, +3310, +3308, +3528,
+3885, +4242, +4460, +4454, +4224, +3855, +3486, +3253, +3243, +3456, +3805, +4154, +4364, +4350, +4112, +3736,
+3359, +3119, +3101, +3306, +3648, +3989, +4192, +4171, +3926, +3543, +3159, +2912, +2887, +3086, +3421, +3756,
+3952, +3924, +3673, +3284, +2894, +2642, +2611, +2804, +3134, +3463, +3654, +3622, +3366, +2971, +2577, +2320,
+2285, +2473, +2799, +3125, +3312, +3276, +3016, +2619, +2221, +1961, +1923, +2109, +2432, +2755, +2940, +2901,
+2640, +2241, +1841, +1580, +1541, +1725, +2048, +2370, +2554, +2515, +2254, +1854, +1455, +1194, +1155, +1340,
+1663, +1986, +2172, +2134, +1874, +1476, +1079,  +819,  +783,  +970, +1296, +1622, +1810, +1775, +1518, +1123,
 +729,  +473,  +441,  +632,  +961, +1291, +1484, +1453, +1201,  +811,  +422,  +171,  +143,  +339,  +674, +1009,
+1208, +1183,  +936,  +552,  +169,   -75,   -96,  +106,  +447,  +789,  +994,  +976,  +736,  +359,   -16,  -254,
 -268,   -58,  +290,  +639,  +852,  +842,  +609,  +240,  -128,  -358,  -364,  -146,  +210,  +567,  +787,  +785,
 +561,  +200,  -160,  -382,  -380,  -154,  +210,  +575,  +803,  +809,  +593,  +240,  -112,  -325,  -315,   -82,
 +290,  +663,  +899,  +913,  +705,  +359,   +14,  -191,  -173,   +67,  +447,  +828, +1071, +1092,  +891,  +552,
 +215,   +15,   +40,  +288,  +674, +1061, +1311, +1338, +1143,  +811,  +479,  +286,  +316,  +569,  +961, +1354,
+1609, +1641, +1451, +1124,  +796,  +607,  +642,  +900, +1296, +1692, +1951, +1987, +1801, +1476, +1152,  +967,
+1004, +1265, +1663, +2062, +2323, +2361, +2177, +1854, +1532, +1348, +1386, +1648, +2047,
#elif 4==HARMONIC_WAVE_AMPLITUDE

#elif 5==HARMONIC_WAVE_AMPLITUDE

#endif

};

union32_type wInArrayTab[128];  //固定25个点 串口2传输下来的时间 需要*25 相当于
								//默认的情况下向后推移了25*4 = 100us
								//DMA固定传输25个数据点 这样的话 时间不能长
								//推出了 下一个点 意义就不大了
u8 USART1_DMA_Buf1[8] = {0};

//u8 SPI_DMA_Table[3] ={0X31 , 0XAA , 0XAA};
u8 SPI_DMA_Table[SIP_DMA_TBL_SIZE] = {0}; 

u8 cSineWaveIndex = 0;

u8 g_bDatReceCnt = 0;
 

/***********************************************************
*   函数说明：数字滤波函数                                 *
*   输入：    1.半字长度数据指针 2.要处理数据的长度        *
*   输出：    无                                           *
*   调用函数：无										   *
*   说明:     取NO的2/5作为头尾忽略值,注意N要大于5,否则	   *
			  不会去头尾                                   *
***********************************************************/
u16 DigitFilter(u16* buf,u8 no)
{
	u8 i,j;
	u16 tmp;
	u8 cut_no=0;
	//排序
	for(i=0;i<no;i++)
	{
		for(j=0;j<no-i-1;j++)
		{	
			
			if(buf[j]>buf[j+1])
			{	
			tmp=buf[j];
			buf[j]=buf[j+1];
			buf[j+1]=tmp;
			}
		}
	}

	if(no>5)
	{
		cut_no=no/5;
	}

	//去头去尾取平均
	tmp=0;
	for(i=cut_no;i<no-cut_no;i++)	//只取中间n-2*cut_no个求平均
		tmp+=buf[i];
	return(tmp/(no-2*cut_no));
}
/***********************************************************
*   函数说明：SPI2发送一个字节的数据                       *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明：	  切记不可忽略SPI的硬件接收,因为读SPI_DR才能清除RXEN
***********************************************************/
 u8 SPI1SendByte(u8 byte)
{
	/*等待发送寄存器空*/
	while((SPI1->SR & SPI_I2S_FLAG_TXE)==RESET);
    /*发送一个字节*/
	SPI2->DR = byte;
	/* 等待接收寄存器有效*/
	while( (SPI1->SR & SPI_I2S_FLAG_RXNE)==RESET );
	return(SPI1->DR);
}


/***********************************************************
*   函数说明：软件驱动初始化函数                           *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：无                                           *
***********************************************************/

void Driver_Init(void)
{
	 USART1_RxBufferInit();
	 USART1_TxBufferInit();
#if 0
	 USART2_RxBufferInit();
	 USART2_TxBufferInit();
#endif	 
}


/***********************************************************
*   函数说明：系统延时函数                                 *
*   输入：    20MS延时的基准输入                           *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：20ms                                            *
***********************************************************/
void Delay_20ms(u32 speed)
{
	u16 i;
	while(speed!=0)
	{
		speed--;
		for(i=0;i<400;i++);
	}
} 


/***********************************************************
*   函数说明：定时器2(普通定时器)重新初始化函数            *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：Port_Init()  RCC_Configuration()             *
***********************************************************/
void TIM2_ReConfiguration(u8 cInTime)
{
	 //TIM2 的时间 作为差值的时间间隔	触发DMA 输出数据到DAC
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* TIM2 clock enable */
  	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

  	/* Time base configuration */
  	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
  	TIM_TimeBaseStructure.TIM_Period = 72*cInTime; // 上位机传输的命令时间单位是US
  	TIM_TimeBaseStructure.TIM_Prescaler = 0x0;       
  	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;    
  	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
  	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

  	/* TIM2 TRGO selection */
  	TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);

//	TIM_Cmd(TIM2, ENABLE);

 
}


#if 0 /* David */
void DMA2_ReConfiguration( u8 cSampleNum)
{
	//只有DAC2 通过DMA通道4 请求的所以这次采用的还是 DAC2通道请求DMA的 有损失
	DMA_InitTypeDef DMA_InitStructure;
  	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);

	/* DMA2 channel4 configuration */
	DMA_DeInit(DMA2_Channel4);					 
	DMA_InitStructure.DMA_PeripheralBaseAddr = 0x40007420;	//DAC_DHR12RD_Address
	DMA_InitStructure.DMA_MemoryBaseAddr = 	(u32)wInArrayTab;  //wInArrayTab是一个32Bit的共用体
															   //写数据时候可以只写高字节 或者低字节
															   // 不会影响另外的字节
//	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)Sine12bit;

	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
	DMA_InitStructure.DMA_BufferSize = cSampleNum+1; 	//默认是在传输的两个点之间差值25个   这样向前推进100us

	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;

 	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
  	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;

 //	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;

	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  //一般模式 一次传输完成就不再传输

	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	  //优先级为高 相当于第2 其之上还有2个级别
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
	DMA_Init(DMA2_Channel4, &DMA_InitStructure);


	DMA_ITConfig(DMA2_Channel4, DMA_IT_TC, ENABLE);	 //DMA2通道4传输完成中断
	
	/* Enable DMA2 Channel4 */
	DMA_Cmd(DMA2_Channel4, ENABLE);


}
#endif



/***********************************************************
*   函数说明：串口停止接收函数                             *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：ST.F.W.3.0                                   *
***********************************************************/
void USART1_StopRx(void)
{
	USART_ITConfig(USART1,USART_IT_RXNE,DISABLE); 
}

/***********************************************************
*   函数说明：串口开始接收使能函数                         *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：ST.F.W.3.0                                   *
***********************************************************/
void USART1_BeginRx(void)
{	
	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE); 
}



/* ==========================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
// *********************************************************
//以下是将通用FIFO缓冲区管理的函数具体配置到USART中		   *
//总共有两个静态的缓冲区，分别用来接收和发送       		   *
// *********************************************************
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===========================================================*/

/***********************************************************
*   函数名：USART1_RxBufferInit                            *
*   输入：    无                         				   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
void USART1_RxBufferInit(void)
{
   bufferInit(&USART1_tRXBufferMana, USART1_RXBuffer, USART1_RX_BUF_SIZE);
}

/***********************************************************
*   函数名：USART1_PutDatatoRxBuffer                       *
*   输入：    要存入FIFO的数据（注意是一个Byte大小）	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
u8 USART1_PutDatatoRxBuffer(u8 dat)
{
 return ( bufferAddToEnd(&USART1_tRXBufferMana,dat ));
}

/*************************************************
**函数名:USART1GetRxBufLen
**功能:获取缓冲中有效数据的长度
**注意事项:获取的值必然为最小值,因为真实长度会不断变化.由于是32位的ARM系统,获取32位数据不存在临界问题,所以可以不考虑关中断
**************************************************/
u16 USART1_GetRxBufferLeftLength(void)
{
	 return(bufferIsNotFull(&USART1_tRXBufferMana));
}

/**************************************************
**函数名:USART1_GetRxBufferData
**功能:从队列中获取数据
**注意事项:
**************************************************/
u8 USART1_GetRxBufferData( void )
{
	return (bufferGetFromFront(&USART1_tRXBufferMana));
}

/***********************************************************
*   函数名：USART1_FlushRxBuffer                           *
*   输入：                                          	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 接收缓冲区清空                                 *
***********************************************************/
void USART1_FlushRxBuffer( void )
{
	bufferFlush(&USART1_tRXBufferMana) ;
}

/***********************************************************
*   函数名：USART1_GetRxBufferCurrentSize                  *
*   输入：    无                                      	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 获得当前数据区的大小                           *
***********************************************************/
u16 USART1_GetRxBufferCurrentSize( void )
{
  return (bufferGetSize(&USART1_tRXBufferMana)) ;
}

/***********************************************************
*   函数名：  USART1_GetBytesFromRxFIFO                    *
*   输入：    1. 从当前的接收缓冲区获取的数据的存放指针	   *
*			  2. 获得的数据的长度                     	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
void USART1_GetBytesFromRxFIFO( u8 *pdat ,u16 length)
{
	u16 num = 0;
	while(num < length)
	{
	   *(pdat++) = USART1_GetRxBufferData();
	   num++;
	}
}


//////////////////////////////////////////
//	以下函数为发送相关
//////////////////////////////////////////
/**************************************************************
接收区缓冲区初始化函数
***************************************************************/
void USART1_TxBufferInit(void)
{
   bufferInit(&USART1_tTXBufferMana, USART1_TXBuffer, USART1_TX_BUF_SIZE);
}

/**************************************************************
** 函数名:USART1PutDatatoTxBuf
** 功能:把数据放进发送队列中,
** 注意事项:用户需要有数据发的时候使用
***************************************************************/
u8 USART1_PutDatatoTxBuffer(u8 dat)
{
 return ( bufferAddToEnd(&USART1_tTXBufferMana,dat ));
}

/*************************************************
**函数名:USART1GetTxBufLen
**功能:获取缓冲中有效数据的长度
**注意事项:获取的值必然为最小值,因为真实长度会不断变化.由于是32位的ARM系统,获取32位数据不存在临界问题,所以可以不考虑关中断
**			所谓有效,是指剩余的可用长度
**************************************************/
u16 USART1_GetTxBufferLeftLength(void)
{
	 return(bufferIsNotFull(&USART1_tTXBufferMana));
}

/**************************************************
**函数名:USART1GetTxBufDat
**功能:从队列中获取数据
**注意事项:调用此函数前请先确保队列中有数据!!
**************************************************/
u8 USART1_GetTxBufferData( void )
{
	return (bufferGetFromFront(&USART1_tTXBufferMana));
}

/***********************************************************
*   函数名：USART1_FlushTxBuffer                           *
*   输入：   无 	                                       *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
void USART1_FlushTxBuffer( void )
{
	bufferFlush(&USART1_tTXBufferMana) ;
}

/***********************************************************
*   函数名：USART1_QueryPutChar                            *
*   输入：  要发送的数据（注意是一个Byte大小）	           *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 此串口操作时以查询的方式发送数据               *
***********************************************************/
u16 USART1_GetTxBufferCurrentSize( void )
{
  return (bufferGetSize(&USART1_tTXBufferMana)) ;
}

/********************************************************
**函数名:USART1_BeginSend
**功能:启动发送
**注意事项:这里使用空中断方式发送,只要发送寄存器为空,则会进入发送空中断,系统再在中断中进行发送
********************************************************/
void UASRT1_BeginSend(void)
{
	USART_ITConfig(USART1,USART_IT_TXE,ENABLE);
}

/*******************************************************
**函数名:USART1_StopSend
**功能:启动发送
**注意事项:这里使用空中断方式发送,只要发送寄存器为空,则会进入发送空中断,系统再在中断中进行发送
********************************************************/
void UASRT1_StopSend(void)
{
	USART_ITConfig(USART1,USART_IT_TXE,DISABLE);
}

/***********************************************************
*   函数名：USART1_QueryPutChar                            *
*   输入：  要发送的数据（注意是一个Byte大小）	           *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 此串口操作时以查询的方式发送数据               *
***********************************************************/
void USART1_QueryPutChar( u8 dat )
{

	USART_SendData(USART1 , (u8)(dat));
	while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
			
}

/***********************************************************
*   函数名：USART1_QueryPutMultiChar                       *
*   输入：  1.要发送的数据的指针 2.要发送数据的长度        *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 此串口操作时以查询的方式发送数据               *
***********************************************************/
void USART1_QueryPutMultiChar( u8 *pdat ,u16 length)
{
	u16 num = 0;
	while(num++ < length)
	{
		USART1_QueryPutChar((u8)(*(pdat++)));
	}
} 
#if 0 /* David */
/***********************************************************
*   函数名：USART1_PutBytesToTxFIFO                        *
*   输入：  1.要发送的数据的指针 2.要发送数据的长度        *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 把数据串的注入到发送FIFO                       *
***********************************************************/
void USART1_PutBytesToTxFIFO( u8 *pdat ,u16 length)
{
	u16 num = 0;
	while(num++ < length)
	{
		USART1_PutDatatoRxBuffer((u8)(*(pdat++)));
	}
}
#endif




#if 0 /* David */

//======================USART2管理函数开始====================
/***********************************************************
*   函数说明：串口停止接收函数                             *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：ST.F.W.3.0                                   *
***********************************************************/
void USART2_StopRx(void)
{
	USART_ITConfig(USART2,USART_IT_RXNE,DISABLE); 
}

/***********************************************************
*   函数说明：串口开始接收使能函数                         *
*   输入：    无                                           *
*   输出：    无                                           *
*   调用函数：ST.F.W.3.0                                   *
***********************************************************/
void USART2_BeginRx(void)
{	
	USART_ITConfig(USART2,USART_IT_RXNE,ENABLE); 
}

/***********************************************************
*   函数名：USART1_RxBufferInit                            *
*   输入：    无                         				   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
void USART2_RxBufferInit(void)
{
   bufferInit(&USART2_tRXBufferMana, USART2_RXBuffer, USART2_RX_BUF_SIZE);
}

/***********************************************************
*   函数名：USART1_PutDatatoRxBuffer                       *
*   输入：    要存入FIFO的数据（注意是一个Byte大小）	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
u8 USART2_PutDatatoRxBuffer(u8 dat)
{
 return ( bufferAddToEnd(&USART2_tRXBufferMana,dat ));
}

/*************************************************
**函数名:USART1GetRxBufLen
**功能:获取缓冲中有效数据的长度
**注意事项:获取的值必然为最小值,因为真实长度会不断变化.由于是32位的ARM系统,获取32位数据不存在临界问题,所以可以不考虑关中断
**************************************************/
u16 USART2_GetRxBufferLeftLength(void)
{
	 return(bufferIsNotFull(&USART2_tRXBufferMana));
}

/**************************************************
**函数名:USART1_GetRxBufferData
**功能:从队列中获取数据
**注意事项:
**************************************************/
u8 USART2_GetRxBufferData( void )
{
	return (bufferGetFromFront(&USART2_tRXBufferMana));
}

/***********************************************************
*   函数名：USART1_FlushRxBuffer                           *
*   输入：                                          	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 接收缓冲区清空                                 *
***********************************************************/
void USART2_FlushRxBuffer( void )
{
	bufferFlush(&USART2_tRXBufferMana) ;
}

/***********************************************************
*   函数名：USART1_GetRxBufferCurrentSize                  *
*   输入：    无                                      	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 获得当前数据区的大小                           *
***********************************************************/
u16 USART2_GetRxBufferCurrentSize( void )
{
  return (bufferGetSize(&USART2_tRXBufferMana)) ;
}

/***********************************************************
*   函数名：  USART1_GetBytesFromRxFIFO                    *
*   输入：    1. 从当前的接收缓冲区获取的数据的存放指针	   *
*			  2. 获得的数据的长度                     	   *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
void USART2_GetBytesFromRxFIFO( u8 *pdat ,u16 length)
{
	u16 num = 0;
	while(num < length)
	{
	   *(pdat++) = USART2_GetRxBufferData();
	   num++;
	}
}

 
//////////////////////////////////////////
//	以下函数为发送相关
//////////////////////////////////////////
/**************************************************************
接收区缓冲区初始化函数
***************************************************************/
void USART2_TxBufferInit(void)
{
   bufferInit(&USART2_tTXBufferMana, USART2_TXBuffer, USART2_TX_BUF_SIZE);
}

/**************************************************************
** 函数名:USART1PutDatatoTxBuf
** 功能:把数据放进发送队列中,
** 注意事项:用户需要有数据发的时候使用
***************************************************************/
u8 USART2_PutDatatoTxBuffer(u8 dat)
{
 return ( bufferAddToEnd(&USART2_tTXBufferMana,dat ));
}

/*************************************************
**函数名:USART1GetTxBufLen
**功能:获取缓冲中有效数据的长度
**注意事项:获取的值必然为最小值,因为真实长度会不断变化.由于是32位的ARM系统,获取32位数据不存在临界问题,所以可以不考虑关中断
**			所谓有效,是指剩余的可用长度
**************************************************/
u16 USART2_GetTxBufferLeftLength(void)
{
	 return(bufferIsNotFull(&USART2_tTXBufferMana));
}

/**************************************************
**函数名:USART1GetTxBufDat
**功能:从队列中获取数据
**注意事项:调用此函数前请先确保队列中有数据!!
**************************************************/
u8 USART2_GetTxBufferData( void )
{
	return (bufferGetFromFront(&USART2_tTXBufferMana));
}

/***********************************************************
*   函数名：USART1_FlushTxBuffer                           *
*   输入：   无 	                                       *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ：                                                *
***********************************************************/
void USART2_FlushTxBuffer( void )
{
	bufferFlush(&USART2_tTXBufferMana) ;
}

/***********************************************************
*   函数名：USART1_QueryPutChar                            *
*   输入：  要发送的数据（注意是一个Byte大小）	           *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 此串口操作时以查询的方式发送数据               *
***********************************************************/
u16 USART2_GetTxBufferCurrentSize( void )
{
  return (bufferGetSize(&USART2_tTXBufferMana)) ;
}

/********************************************************
**函数名:USART1_BeginSend
**功能:启动发送
**注意事项:这里使用空中断方式发送,只要发送寄存器为空,则会进入发送空中断,系统再在中断中进行发送
********************************************************/
void UASRT2_BeginSend(void)
{
	USART_ITConfig(USART2,USART_IT_TXE,ENABLE);
}

/*******************************************************
**函数名:USART1_StopSend
**功能:启动发送
**注意事项:这里使用空中断方式发送,只要发送寄存器为空,则会进入发送空中断,系统再在中断中进行发送
********************************************************/
void UASRT2_StopSend(void)
{
	USART_ITConfig(USART2,USART_IT_TXE,DISABLE);
}

/***********************************************************
*   函数名：USART1_QueryPutChar                            *
*   输入：  要发送的数据（注意是一个Byte大小）	           *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 此串口操作时以查询的方式发送数据               *
***********************************************************/
void USART2_QueryPutChar( u8 dat )
{

	USART_SendData(USART2 , (u8)(dat));
	while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);
			
}

/***********************************************************
*   函数名：USART1_QueryPutMultiChar                       *
*   输入：  1.要发送的数据的指针 2.要发送数据的长度        *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 此串口操作时以查询的方式发送数据               *
***********************************************************/
void USART2_QueryPutMultiChar( u8 *pdat ,u16 length)
{
	u16 num = 0;
	while(num++ < length)
	{
		USART2_QueryPutChar((u8)(*(pdat++)));
	}
}

/***********************************************************
*   函数名：USART1_PutBytesToTxFIFO                        *
*   输入：  1.要发送的数据的指针 2.要发送数据的长度        *
*   输出：    无                                           *
*   调用函数：无                                           *
*   说明 ： 把数据串的注入到发送FIFO                       *
***********************************************************/
void USART2_PutBytesToTxFIFO( u8 *pdat ,u16 length)
{
	u16 num = 0;
	while(num++ < length)
	{
		USART2_PutDatatoRxBuffer((u8)(*(pdat++)));
	}
}
#endif

