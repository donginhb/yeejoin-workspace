
/*
 * Copyright (c) 2006-2008 by Roland Riegel <feedback@roland-riegel.de>
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "enc28j60_io.h"
#include "enc28j60_packet.h"

/**
 * \addtogroup net
 *
 * @{
 */
/**
 * \addtogroup net_driver
 *
 * @{
 */
/**
 * \addtogroup net_driver_enc28j60
 *
 * @{
 */
/**
 * \file
 * Microchip ENC28J60 packet handling (license: GPLv2)
 *
 * \author Roland Riegel
 */

static uint16_t packet_ptr = RX_START;

/**
 * Fetches a pending packet from the RAM buffer of the ENC28J60.
 *
 * The packet is written into the given buffer and the size of the packet
 * (ethernet header plus payload, exclusive the CRC) is returned.
 *
 * Zero is returned in the following cases:
 * - There is no packet pending.
 * - The packet is too large to completely fit into the buffer.
 * - Some error occured.
 *
 * \param[out] buffer The pointer to the buffer which receives the packet.
 * \param[in] buffer_len The length of the buffer.
 * \returns The packet size in bytes on success, \c 0 in the cases noted above.
 */
uint16_t enc28j60_receive_packet(uint8_t* buffer, uint16_t buffer_len)
{
	if(!enc28j60_read(EPKTCNT))
		return 0;

	/* set read pointer */
	enc28j60_write(ERDPTL, packet_ptr & 0xff);
	enc28j60_write(ERDPTH, packet_ptr >> 8);

	/* read pointer to next packet */
	packet_ptr = ((uint16_t) enc28j60_read_buffer_byte()) |
				 ((uint16_t) enc28j60_read_buffer_byte()) << 8;

	/* read packet length */
	uint16_t packet_len = ((uint16_t) enc28j60_read_buffer_byte()) |
						  ((uint16_t) enc28j60_read_buffer_byte()) << 8;
	packet_len -= 4; /* ignore CRC */

	/* read receive status */
	enc28j60_read_buffer_byte();
	enc28j60_read_buffer_byte();

	/* read packet */
	if(packet_len <= buffer_len)
		enc28j60_read_buffer(buffer, packet_len);

	/* free packet memory */
	/* DS80349C.errata #14 */
	uint16_t packet_ptr_errata = packet_ptr - 1;
	if(packet_ptr_errata < RX_START || packet_ptr_errata > RX_END)
		packet_ptr_errata = RX_END;
	enc28j60_write(ERXRDPTL, packet_ptr_errata & 0xff);
	enc28j60_write(ERXRDPTH, packet_ptr_errata >> 8);

	/* decrement packet counter */
	enc28j60_set_bits(ECON2, (1 << ECON2_PKTDEC));

	if(packet_len <= buffer_len)
		return packet_len;
	else
		return 0;
}

/**
 * Writes a packet to the RAM buffer of the ENC28J60 and starts transmission.
 *
 * The packet buffer contains the ethernet header and the payload without CRC.
 * The checksum is automatically generated by the on-chip calculator.
 *
 * \param[in] buffer A pointer to the buffer containing the packet to be sent.
 * \param[in] buffer_len The length of the ethernet packet header plus payload.
 * \returns \c true if the packet was sent, \c false otherwise.
 */
bool enc28j60_send_packet(uint8_t* buffer, uint16_t buffer_len)
{
	if(!buffer || !buffer_len)
		return false;

	/* DS80349C.errata #12 */
	if(enc28j60_read(EIR) & (1 << EIR_TXERIF)) {
		enc28j60_set_bits(ECON1, (1 << ECON1_TXRST));
		enc28j60_clear_bits(ECON1, (1 << ECON1_TXRST));
	}

	/* wait until previous packet was sent */
	while(enc28j60_read(ECON1) & (1 << ECON1_TXRTS));

	/* set start of packet */
	enc28j60_write(ETXSTL, TX_START & 0xff);
	enc28j60_write(ETXSTH, TX_START >> 8);

	/* set end of packet */
	enc28j60_write(ETXNDL, (TX_START + buffer_len) & 0xff);
	enc28j60_write(ETXNDH, (TX_START + buffer_len) >> 8);

	/* set write pointer */
	enc28j60_write(EWRPTL, TX_START & 0xff);
	enc28j60_write(EWRPTH, TX_START >> 8);

	/* per packet control byte */
	enc28j60_write_buffer_byte(0x00);

	/* send packet */
	enc28j60_write_buffer(buffer, buffer_len);

	/* start transmission */
	enc28j60_set_bits(ECON1, (1 << ECON1_TXRTS));

	return true;
}

/**
 * @}
 * @}
 * @}
 */

